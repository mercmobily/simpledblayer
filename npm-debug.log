0 info it worked if it ends with ok
1 verbose cli [ '/usr/local/bin/node', '/usr/local/bin/npm', 'publish' ]
2 info using npm@1.4.3
3 info using node@v0.10.26
4 verbose publish [ '.' ]
5 verbose cache add [ '.', null ]
6 verbose cache add name=undefined spec="." args=[".",null]
7 verbose parsed url { protocol: null,
7 verbose parsed url   slashes: null,
7 verbose parsed url   auth: null,
7 verbose parsed url   host: null,
7 verbose parsed url   port: null,
7 verbose parsed url   hostname: null,
7 verbose parsed url   hash: null,
7 verbose parsed url   search: null,
7 verbose parsed url   query: null,
7 verbose parsed url   pathname: '.',
7 verbose parsed url   path: '.',
7 verbose parsed url   href: '.' }
8 silly lockFile 3a52ce78- .
9 verbose lock . /home/merc/.npm/3a52ce78-.lock
10 verbose tar pack [ '/home/merc/tmp/npm-32208-WIZAN6gK/1397883869041-0.6361510071437806/tmp.tgz',
10 verbose tar pack   '.' ]
11 verbose tarball /home/merc/tmp/npm-32208-WIZAN6gK/1397883869041-0.6361510071437806/tmp.tgz
12 verbose folder .
13 info prepublish simpledblayer@0.3.16
14 silly lockFile 1f1177db-tar tar://.
15 verbose lock tar://. /home/merc/.npm/1f1177db-tar.lock
16 silly lockFile 86793b23-69041-0-6361510071437806-tmp-tgz tar:///home/merc/tmp/npm-32208-WIZAN6gK/1397883869041-0.6361510071437806/tmp.tgz
17 verbose lock tar:///home/merc/tmp/npm-32208-WIZAN6gK/1397883869041-0.6361510071437806/tmp.tgz /home/merc/.npm/86793b23-69041-0-6361510071437806-tmp-tgz.lock
18 silly lockFile 1f1177db-tar tar://.
19 silly lockFile 1f1177db-tar tar://.
20 silly lockFile 86793b23-69041-0-6361510071437806-tmp-tgz tar:///home/merc/tmp/npm-32208-WIZAN6gK/1397883869041-0.6361510071437806/tmp.tgz
21 silly lockFile 86793b23-69041-0-6361510071437806-tmp-tgz tar:///home/merc/tmp/npm-32208-WIZAN6gK/1397883869041-0.6361510071437806/tmp.tgz
22 verbose tar unpack /home/merc/tmp/npm-32208-WIZAN6gK/1397883869041-0.6361510071437806/tmp.tgz
23 silly lockFile 08dda5a7-69041-0-6361510071437806-package tar:///home/merc/tmp/npm-32208-WIZAN6gK/1397883869041-0.6361510071437806/package
24 verbose lock tar:///home/merc/tmp/npm-32208-WIZAN6gK/1397883869041-0.6361510071437806/package /home/merc/.npm/08dda5a7-69041-0-6361510071437806-package.lock
25 silly lockFile 86793b23-69041-0-6361510071437806-tmp-tgz tar:///home/merc/tmp/npm-32208-WIZAN6gK/1397883869041-0.6361510071437806/tmp.tgz
26 verbose lock tar:///home/merc/tmp/npm-32208-WIZAN6gK/1397883869041-0.6361510071437806/tmp.tgz /home/merc/.npm/86793b23-69041-0-6361510071437806-tmp-tgz.lock
27 silly gunzTarPerm modes [ '755', '644' ]
28 silly gunzTarPerm extractEntry package.json
29 silly gunzTarPerm modified mode [ 'package.json', 436, 420 ]
30 silly gunzTarPerm extractEntry README.md
31 silly gunzTarPerm modified mode [ 'README.md', 436, 420 ]
32 silly gunzTarPerm extractEntry LICENSE
33 silly gunzTarPerm modified mode [ 'LICENSE', 436, 420 ]
34 silly gunzTarPerm extractEntry SimpleDbLayer.js
35 silly gunzTarPerm modified mode [ 'SimpleDbLayer.js', 436, 420 ]
36 silly gunzTarPerm extractEntry test.js
37 silly gunzTarPerm modified mode [ 'test.js', 436, 420 ]
38 silly lockFile 08dda5a7-69041-0-6361510071437806-package tar:///home/merc/tmp/npm-32208-WIZAN6gK/1397883869041-0.6361510071437806/package
39 silly lockFile 08dda5a7-69041-0-6361510071437806-package tar:///home/merc/tmp/npm-32208-WIZAN6gK/1397883869041-0.6361510071437806/package
40 silly lockFile 86793b23-69041-0-6361510071437806-tmp-tgz tar:///home/merc/tmp/npm-32208-WIZAN6gK/1397883869041-0.6361510071437806/tmp.tgz
41 silly lockFile 86793b23-69041-0-6361510071437806-tmp-tgz tar:///home/merc/tmp/npm-32208-WIZAN6gK/1397883869041-0.6361510071437806/tmp.tgz
42 verbose tar pack [ '/home/merc/.npm/simpledblayer/0.3.16/package.tgz',
42 verbose tar pack   '/home/merc/tmp/npm-32208-WIZAN6gK/1397883869041-0.6361510071437806/package' ]
43 verbose tarball /home/merc/.npm/simpledblayer/0.3.16/package.tgz
44 verbose folder /home/merc/tmp/npm-32208-WIZAN6gK/1397883869041-0.6361510071437806/package
45 silly lockFile 08dda5a7-69041-0-6361510071437806-package tar:///home/merc/tmp/npm-32208-WIZAN6gK/1397883869041-0.6361510071437806/package
46 verbose lock tar:///home/merc/tmp/npm-32208-WIZAN6gK/1397883869041-0.6361510071437806/package /home/merc/.npm/08dda5a7-69041-0-6361510071437806-package.lock
47 silly lockFile ae91da98-simpledblayer-0-3-16-package-tgz tar:///home/merc/.npm/simpledblayer/0.3.16/package.tgz
48 verbose lock tar:///home/merc/.npm/simpledblayer/0.3.16/package.tgz /home/merc/.npm/ae91da98-simpledblayer-0-3-16-package-tgz.lock
49 silly lockFile 08dda5a7-69041-0-6361510071437806-package tar:///home/merc/tmp/npm-32208-WIZAN6gK/1397883869041-0.6361510071437806/package
50 silly lockFile 08dda5a7-69041-0-6361510071437806-package tar:///home/merc/tmp/npm-32208-WIZAN6gK/1397883869041-0.6361510071437806/package
51 silly lockFile ae91da98-simpledblayer-0-3-16-package-tgz tar:///home/merc/.npm/simpledblayer/0.3.16/package.tgz
52 silly lockFile ae91da98-simpledblayer-0-3-16-package-tgz tar:///home/merc/.npm/simpledblayer/0.3.16/package.tgz
53 silly lockFile 5b981dfe-npm-simpledblayer-0-3-16-package /home/merc/.npm/simpledblayer/0.3.16/package
54 verbose lock /home/merc/.npm/simpledblayer/0.3.16/package /home/merc/.npm/5b981dfe-npm-simpledblayer-0-3-16-package.lock
55 silly lockFile 5b981dfe-npm-simpledblayer-0-3-16-package /home/merc/.npm/simpledblayer/0.3.16/package
56 silly lockFile 5b981dfe-npm-simpledblayer-0-3-16-package /home/merc/.npm/simpledblayer/0.3.16/package
57 verbose tar unpack /home/merc/.npm/simpledblayer/0.3.16/package.tgz
58 silly lockFile 9161e9c7-npm-simpledblayer-0-3-16-package tar:///home/merc/.npm/simpledblayer/0.3.16/package
59 verbose lock tar:///home/merc/.npm/simpledblayer/0.3.16/package /home/merc/.npm/9161e9c7-npm-simpledblayer-0-3-16-package.lock
60 silly lockFile ae91da98-simpledblayer-0-3-16-package-tgz tar:///home/merc/.npm/simpledblayer/0.3.16/package.tgz
61 verbose lock tar:///home/merc/.npm/simpledblayer/0.3.16/package.tgz /home/merc/.npm/ae91da98-simpledblayer-0-3-16-package-tgz.lock
62 silly gunzTarPerm modes [ '755', '644' ]
63 silly gunzTarPerm extractEntry package.json
64 silly gunzTarPerm extractEntry README.md
65 silly gunzTarPerm extractEntry LICENSE
66 silly gunzTarPerm extractEntry SimpleDbLayer.js
67 silly gunzTarPerm extractEntry test.js
68 silly lockFile 9161e9c7-npm-simpledblayer-0-3-16-package tar:///home/merc/.npm/simpledblayer/0.3.16/package
69 silly lockFile 9161e9c7-npm-simpledblayer-0-3-16-package tar:///home/merc/.npm/simpledblayer/0.3.16/package
70 silly lockFile ae91da98-simpledblayer-0-3-16-package-tgz tar:///home/merc/.npm/simpledblayer/0.3.16/package.tgz
71 silly lockFile ae91da98-simpledblayer-0-3-16-package-tgz tar:///home/merc/.npm/simpledblayer/0.3.16/package.tgz
72 verbose chmod /home/merc/.npm/simpledblayer/0.3.16/package.tgz 644
73 verbose chown /home/merc/.npm/simpledblayer/0.3.16/package.tgz [ 1000, 1000 ]
74 silly lockFile 3a52ce78- .
75 silly lockFile 3a52ce78- .
76 silly publish { name: 'simpledblayer',
76 silly publish   description: 'Simple, generic, no fuss DB layer for NodeJS',
76 silly publish   keywords: [ 'javascript', 'database', 'mongo' ],
76 silly publish   main: 'SimpleDbLayer.js',
76 silly publish   version: '0.3.16',
76 silly publish   private: false,
76 silly publish   repository:
76 silly publish    { type: 'git',
76 silly publish      url: 'https://github.com/mercmobily/simpledblayer' },
76 silly publish   author: { name: 'Tony Mobily' },
76 silly publish   dependencies: { simpledeclare: '0.3.x', async: '0.2.x' },
76 silly publish   readme: 'simpledblayer\n=============\n\nSimpleDbLayer is a module that will allow you to connect and query a DB server. Key features:\n\n* It doesn\'t manage connections. You will have to create a connection to the database and pass it\n* Simple querying. You cannot create complex queries with nested ANDs and ORs -- only one level of AND and OR. You can however check for equality, greater/smaller than, starts with/ends with/contains, etc. as well as sorting and limiting/ranges\n* It has full cursor support\n* It uses a schema to cast/validate fields.\n* It allows 1-level joins in queryes and data fetching. This means that you can load a record and have all of its "lookup" fields, or all of its 1:n children, pre-loaded.\n* It is written with very simple, Object Oriented code using [simpleDeclare](https://github.com/mercmobily/simpleDeclare)\n\n\n## TODO\n\nTodo when everything is stable and non-structural, non-API-changing changes can be made:\n\n* searchableHash -> change it to the field type, \'string\', \'id\', etc.\n* make DB a normal parameter, rather than the constructor\'s third parameter\n* take out "join" for lookup tables, since it can be inferred easily\n\n# Creating a layer\n\n## Create a DB connection\n\nSimpleDbLayer does NOT handle DB connections for you. It\'s your responsibility to connect to the database and pass the connection object to it.\nFor MongoDB, you can use Mongo\'s connect call:\n\n    var mongo = require(\'mongo\');\n    mongo.MongoClient.connect( \'mongodb://localhost/hotplate\', {}, function( err, db ){\n     // db exists here\n    }; \n\nOr for Tingodb just create the DB object:\n\n    var tingo = require("tingodb")({});\n    var db = new tingo.Db(\'/tmp/someDB\', {} );\n    // db exists here\n\n## Make up the DB Layer class\n\nIn order to use this class, you will need to _mixin_ the basic SimpleDbLayer class and a DB-specific mixin. If you are not used to mixins, don\'t be scared: it\'s simpler than it sounds.\n\nHere is how you make up the class:\n\n    var mongo = require(\'mongodb\');\n\n    var declare = require(\'simpledeclare\');\n    var SimpleDbLayer = require(\'simpledblayer\'); // This is the main class\n    var SimpleSchema = require(\'simpleschema\'); // This will be used to define the schema\n    var SimpleDbLayerMongo = require(\'simpledblayer-mongo\'); // This is the layer-specific mixin\n\n    // Connect to the database\n    mongo.MongoClient.connect(\'mongodb://localhost/someDB\', {}, function( err, db ){\n\n      // Make up the database class\n      var DbLayer = declare( [ SimpleDbLayer, SimpleDbLayerMongo ], { db: db } );\n\n      // ...your program goes here\n\n    });\n\nOr, you could use TingoDB:\n\n    var tingo = require("tingodb")({});\n\n    var declare = require(\'simpledeclare\');\n    var SimpleDbLayer = require(\'simpledblayer\'); // This is the main class\n    var SimpleSchema = require(\'simpleschema\'); // This will be used to define the schema\n    var SimpleDbLayerTingo = require(\'simpledblayer-tingo\'); // This is the layer-specific mixin\n\n    var db = new tingo.Db(\'/tmp/someDB\', {} );\n\n    // Make up the database class\n    var DbLayer = declare( [ SimpleDbLayer, SimpleDbLayerTingo ], { db: db } );\n\n    // ...your program goes here\n\nThere is no difference in functionality between the two layers.\n\n## Create your layer object\n\nOnce you have your DbLayer class, it\'s up to you to create objects which will then modify specific database tables/collections:\n\n    var people = new DbLayer( \'people\', {\n\n      schema: new SimpleSchema({\n        id: { type: \'id\' },\n        name: { type: \'string\', required: true },\n        surname: { type: \'string\', searchable: true },\n        age: { type: \'number\', searchable: true },\n      }),\n\n      idProperty: \'id\',\n\n    } );\n\nNote how `people` is an object which will be tied to the table/collection `people`.\nThe second parameter in the constructor is a set of parameters, which in this case include 1) The schema definition 2) the `idProperty`, which needs to be set and refer to an existing field.\n\nSimpleschema is an object based on [SimpleSchema](https://github.com/mercmobily/SimpleSchema), which provides a way to define extensible schemas with a very simple API. In this case, the `name` field is required whereas `surname` and `age` are not required but are searchable.\n\nThe `id` field, since it was set as `isProperty`, is forced as `required` and `searchable`.\n\n## Create your layer object with a specific db connection\n\nYou can pass the connection variable `db` as the third parameter of the DbLayer constructor if you like:\n\n    var logEntries = new DbLayer( \'logger\', { ...layer parameters... }, someOtherDb );\n\nIn this case, logEntries will be tied to the table `logger`, but queries will be directed to `someOtherDb` rather than `db`.\n\n## Setting a hard limit on queries\n\nCursor-less queries on large data sets will likely chew up huge amounts of memory. This is why you can set a hard limit on queries:\n\n      var DbLayer = declare( [ SimpleDbLayer, SimpleDbLayerMongo ], { db: db, hardLimitOnQueries: 10 } );\n\nThis will imply that each non-cursor query will only ever return 10 items max. You can also set this limit on specific objects by passing hardLimitOnQueries as a parameter:\n\n    var DbLayer = declare( [ SimpleDbLayer, SimpleDbLayerMongo ], { db: db } );\n    var people = new DbLayer( \'people\', {  ...layer parameters..., hardLimitOnQueries: 10 } );\n\nNote that hardLimtOnQueries only ever applies to non-cursor queries.\n\n## Validation errors\n\nThe `insert` and `update` operations will trigger validation against the schema. If validation fails, the callback is called with an error. The error object is created by SimpleDbLayer like this:\n\n    var error = new Error( { errors: errorsArray } );\n    error.errors = errorsArray;\n\nThe variable `errorsArray` is an array of objects, where each object has `field` and `message` defined. For example:\n\n    [ { field: \'age\', message: \'Age is invalid\' }, { field: \'name\', message: \'Field is required: name\' } ] \n\nYou can set the constructor used to create the error objects by passing a `SchemaError` parameter when you define the layer:\n\n    var people = new DbLayer( \'people\', {\n\n      schema: new SimpleSchema({\n        // ... your schema here\n      }),\n\n      idProperty: \'id\',\n\n      SchemaError: YourPersonalisedErrorConstructor\n    } );\n\nYou can also define a `SchemaError` that will be used by all instances:\n\n    var people = new DbLayer( \'people\', {  ...layer parameters..., SchemaError: SomeOtherSchemaError } );\n\n# Running queries\n\n## Querying: insert\n\nTo insert data into your table:\n\n    people.insert( { id: 1, name: \'Tony\', surname: \'Mobily\', age: 37 }, { returnRecord: true }, function( err, record ){\n\nThe second parameter is optional. If you pass it:\n\n* If `returnRecord` is true, then the callback will be called with `record` representing the record just created.\n* If `skipValidation` is true, then the validation of the data against the schema will be skipped\n\n## Querying: update\n\nThis is a simple update:\n\n    people.update( { conditions: { and: [ name: { type: \'startsWith\', value: \'D\' }  ] } }, { name: \'Changed\' }, { deleteUnsetFields: true, multi: true }, function( err, num ){\n\nThe second parameter is optional. If you pass it:\n\n* If `multi` is set to `true`, all records matching the search will be updated. Otherwise, only one record will be updated.\n* If `deleteUnsetFields` is set to `true`, then any field that is not defined in the update object will be set as empty in the database. Basically, it\'s a "full record update" regardless of what was passed. Validation will fail if a field is required by the schema and it\'s not set while this option is `true`.\n* If `skipValidation` is true, then the validation of the data against the schema will be skipped\n\n## Querying: delete\n\nTo delete, just use the `delete()` method:\n\n    people.delete( { conditions: { and: [ { field: \'age\', type: \'lt\', value: 30 }, { field: \'name\', type: \'eq\', value: \'Chiara\' } ] } }, { multi: true } ,  function( err, howMany ){\n\nThe second parameter is optional. If you pass it:\n\n* If `multi` is set to `true`, all records matching the search will be deleted. Otherwise, only one record will be deleted.\n\n## Querying: select\n\nFor normal queries:\n\n    people.select( {}, { useCursor: false , delete: false }, function( err, data, total, grandTotal ){\n\nIn normal queries, you can also pass the `skipHardLimitOnQueries` flag. However, remember that if you have a large data set, non-cursor queries will attempt to place the whole thing in memory and will probably kill your server:\n\n    people.select( {}, { useCursor: false , delete: false, skipHardLimitOnQueries: true }, function( err, data, total, grandTotal ){\n\nFor cursor queries (for which `skipHardLimitOnQueries` is implied since it would be pointless):\n\n    people.select( {}, { useCursor: true , delete: false }, function( err, cursor, total, grandTotal ){\n\nHere, `total` is the number of records returned, and `grandTotal` is the _total_ number of records that satisfy the query without taking into consideration the required ranges.\n\nNormal queries will just return the data as an array of values. Cursor queries will return an object with the methods next(), rewind() and close(). For example:\n\n    people.select( {}, { useCursor: true , delete: false }, function( err, cursor ){\n    if( err ){\n      console.log( "ERROR!", err );\n    } else {\n      cursor.next( function( err, record ){\n        if( err ){\n          console.log( "ERROR!", err );\n        } else {\n          console.log( "The first record:" );\n          console.log( record );\n        } \n      }\n    }\n\nThis is what the search filter can look like:\n\n    var searchFilter = { \n  \n      ranges: {\n        from: 1,\n        to: 7\n        limit: 7\n      },\n  \n      conditions: {\n  \n        and: [\n          { \n            field: \'name\',\n            type: \'startsWith\',\n            value: \'To\'\n          },\n        ],\n  \n        or: [\n  \n          {\n            field: \'age\',\n            type: \'lt\',\n            value: 12 \n          },\n          {\n            field: \'age\',\n            type: \'gt\',\n            value: 65\n          },\n\n        ],\n      },\n  \n      sort: {\n        name: -1,\n        age: 1\n      }\n  \n    };\n\nConditions are grouped into `and` and `or` ones. The db query will be the list of `and` conditions _linked with `and`_ to the list of `or` conditions. See it as `A and B and C and (D or E of F )` where `A`, `B` and `C` are the `and` conditions, and `D`, `E`, `F` are the `or` conditions.\n\nThe possible comparison types are: `is` `eq` `lt` `lte` `gt` `gte` `startWith` `startsWith` `contain` `contains` `endsWith` `endWith`.\n\nIf the `delete` field is on (it\'s off by default), the driver will _delete_ any fetched record. For straight selects, it will delete all records _before_ calling your callback. For cursor-driven selects, it will delete records as they are fetched with `cursor.next()` \n\nRanges can have `from`, `to` and `limit` set. If `fields` are missing, the others are automatically worked out.\nFor sorting, -1 means from smaller to bigger and 1 means from bigger to smaller.\n\n# Automatic loading of children (joins)\n\nSimpleDbLayer does _not_ support complex joins. In fact, at the beginning it didn\'t support joins at all. However, after real world usage of the library, it became apparent that some level of joins was important to easy application development.\n\n## Define nested layers\n\nYou can now define a layer as "child" of another one:\n\n    var people = new DbLayer( \'people\', {\n\n      schema: new SimpleSchema({\n        id: { type: \'id\' },\n        name: { type: \'string\', required: true },\n        surname: { type: \'string\', searchable: true },\n        age: { type: \'number\', searchable: true },\n      }),\n\n      idProperty: \'id\',\n\n      nested: [\n        {\n          layer: \'emails\',\n          join: { personId: \'id\' },\n          type: \'multiple\',\n        },\n      ]\n\n    } );\n\n    var emails = new DbLayer( \'emails\', {\n\n      schema: new SimpleSchema({\n        id: { type: \'id\' },\n        personId: { type: \'id\' },\n        email: { type: \'string\', required: true },\n      }),\n\n      idProperty: \'id\',\n\n      nested: [\n        {\n          layer: \'people\',\n          type: \'lookup\',\n          join: { id: \'personId\' },\n          parentField: \'personId\',\n        }\n      ],\n    } );\n\n    SimpleDbLayer.initLayers(); // <--- IMPORTANT!!!\n\n\n***It\'s absolutely crucial that you run `SimpleDbLayer.initLayers()` before running queries if you have nested layers.***\n\nAs you can see, each layer is created with an extra `nested` parameter, which defines:\n\n* `layer`. The layer you want to automatically load records from\n* `type`. How you want to load your records. If you use `multiple`, SimpleDbLayer will auto-load all children records; with `lookup`, it will only load one record\n* `join`. How the record will be looked up in the parent table. It\'s a hash object, where the key is the field _foreign_ to the layer that is being defined, and the value is the field _local_ to the layer that is being defined.\n* `parentField`. Only required when `type` is `lookup`, this is the name of the field in the `local` layer that is being defined that will be used.\n\nThis functionality affects `select()` calls: basically, every time you fetch records, SimpleDbLayer will return a record with a `_children` hash.\n\n## Getting the results\n\nAssume that you insert:\n\n    people.insert( {\n\n      id: 100,\n      name: \'Tony\',\n      surname: \'Mobily\',\n      age: 37\n\n    }, { returnRecord: true }, function( err, record ){\n    \n      if( err ) return cb( err );\n\n      email.insert( {\n\n        id: 10,\n        personId: 100,\n        email: \'tony@example.com\'\n\n      }, { returnRecord: true }, function( err, record ){\n        if( err ) return cb( err );\n\n      email.insert( {\n\n        id: 11,\n        personId: 100,\n        email: \'tonyAnotherOne@example.com\'\n\n      }, { returnRecord: true }, function( err, record ){\n        if( err ) return cb( err );\n\n        //...\n\nWhen fetching the person with id 100:\n\n    people.select( { conditions: { and: [ { field: \'id\', type: \'eq\', value: 100 } ] } }, { children: true }, function( err, data ){\n\n\nSince `children: true` is passed in the option, this will be returned:\n\n    {\n      id: 100,\n      name: \'Tony\',\n      surname: \'Mobily\',\n      age: 37,\n      _children: {\n        emails: [\n        \n          {\n            id: 10,\n            personId: 100,\n            email: \'tony@example.com\'\n            _children: {},\n          },\n\n          {\n            id: 11,\n            personId: 100,\n            email: \'tonyAnotherOne@example.com\'\n            _children: {},\n          }\n\n        ],\n\n      }\n    }\n\n\nWhen fetching the email with id 10:\n\n    emails.select( { conditions: { and: [ { field: \'id\', type: \'eq\', value: 10 } ] } }, { children: true }, function( err, data ){\n\n, it will return:\n\n    {    \n      id: 10,\n      personId: 100,\n      email: \'tony@example.com\',\n      _children: {\n\n        personId: {\n          id: 100,\n          name: \'Tony\',\n          surname: \'Mobily\',\n          age: 37\n        },\n      }\n    }\n\nFinally, you can change the name of the `_children` field when instantiating the class, by setting a different `childrenField` attribute:\n\n    var people = new DbLayer( \'people\', {\n\n      schema: new SimpleSchema({\n        id: { type: \'id\' },\n        name: { type: \'string\', required: true },\n        surname: { type: \'string\', searchable: true },\n        age: { type: \'number\', searchable: true },\n      }),\n\n      idProperty: \'id\',\n\n      nested: [\n        {\n          layer: \'emails\',\n          join: { personId: \'id\' },\n          type: \'multiple\',\n        },\n      ]\n\n      childrenField: \'_children\',\n    } );\n\n\n# Positioning\n\nWhen records are fetched (using `select`) without chosing any `sort`ing options, they are returned in random order. However, in web applications you often want to decide the `placement` of an element, in order to allow drag&drop sorting etc.\n\nPositioning is tricky to manage from the application layer, as changing a field\'s position requires the update of several records in the database. This is why SimpleDbLayer handles positioning for you.\n\n## Basic positioning\n\nIf you have a "flat" table, you can simply define the `positionField` attribute when you define the constructor:\n\n    var people = new DbLayer( \'people\', {\n\n      schema: new SimpleSchema({\n        id: { type: \'id\' },\n        name: { type: \'string\', required: true },\n        surname: { type: \'string\', searchable: true },\n        age: { type: \'number\', searchable: true },\n      }),\n\n      idProperty: \'id\',\n\n      positionField: \'position\',\n    } );\n\nNote that `positionField` is _not_ defined in the schema. In fact, it will be completely _invisible_ to the application using SimpleDbLayer: it won\'t be returned in `select` queries, and won\'t be updatable.\n\nImagine that you add some data:\n\n    var tony = { id: 1, name: \'Tony\', surname: \'Mobily\', age: 37 };\n    var chiara = { id: 2, name: \'Chiara\', surname: \'Mobily\', age: 23 };\n\n    people.insert( tony, { returnRecord: true }, function( err, tony ){\n      if( err ) return cb( err );\n\n      people.insert( chiara, { returnRecord: true }, function( err, chiara ){\n        if( err ) return cb( err );\n        // ...\n\nAt this point, you decide to position the record with `id` 2 (chiara) _before_ the one with id `1`. Just run:\n\n    people.reposition( chiara, 1, function( err ){\n\nThe records\' `position` field on the database will be updated so that they are in the right order.\n\nFrom now on, when running `select` calls _without_ any sorting options, SimpleDbLayer will return them sorted by the `position` field.\n\n## Nested record positioning\n\nIn most cases, your records will be "nested" to other ones. Imagine these two layers:\n\n    var people = new DbLayer( \'people\', {\n\n      schema: new SimpleSchema({\n        id: { type: \'id\' },\n        name: { type: \'string\', required: true },\n        surname: { type: \'string\', searchable: true },\n        age: { type: \'number\', searchable: true },\n      }),\n\n      idProperty: \'id\',\n\n    } );\n\n    var emails = new DbLayer( \'emails\', {\n\n      schema: new SimpleSchema({\n        id: { type: \'id\' },\n        personId: { type: \'id\' },\n        email: { type: \'string\', required: true },\n      }),\n\n      idProperty: \'id\',\n\n    } );\n\nEach person will have a number of emails -- all the ones with the corresponding personId. When dealing with positioning, you need to take into account what fields define the \'ordering grouping\': placing an email address before another one should only ever affect the records belonging to the same person.\n\nThis is where the `positionBase` array comes in.\n\nThis is how you would make the `emails` layer able to handle positioning:\n\n    var emails = new DbLayer( \'emails\', {\n\n      schema: new SimpleSchema({\n        id: { type: \'id\' },\n        personId: { type: \'id\' },\n        email: { type: \'string\', required: true },\n      }),\n\n      idProperty: \'id\',\n\n      positionField: \'position\',\n      positionBase: [ \'personId\' ],\n\n    } );\n\nThe attribute `positionBase` basically decides the domain in which the reordering will happen: only records where `personId` matches the moving record\'s `personId` will be affected by repositioning.\n\n\n# Indexing\n\nYou can create and delete indexes using SimpleDbLayer.\nThe methods are:\n\n## `makeIndex( keys, name, options, cb )`\n\nThe method `makeIndex` will create an index. When calling the function:\n\n* `keys` is an hash where each key is the field name, and each value can be `1` (ascending order) or `-1` (descending order). So, if you have `{ name: 1, surname: 1 }`, the database will be instructed to create an index with the fields `name` and `surname`, both in ascending order.\n* `name` is the name of your index.\n* `options` is a hash where: `{ background: true }` will start the process in background; `unique` will instruct the database that the index will need to be unique; `name` will force the index name to a specific label, rather than the database\'s default.\n\n## `dropIndex( name, cb)`\n\nThis metod `dropIndex()` will drop an index.\n\n## `dropAllIndexes()`\n\nThe method `dropAllIndexes` will drop all indexes for the table/collection.\n\n## `generateSchemaIndexes()`\n\nThis function is used to generate indexes depending on what fields are marked as `searchable` in the schema. The implementation of this depends on the capabilities and architecture of the database server you are using. The goal is to make sure that all searches are based on indexes.\n\nImagine that you have a schema so defined:\n\n    schema: new SimpleSchema({\n      id: { type: \'id\' },\n      name: { type: \'string\', required: true },\n      surname: { type: \'string\', searchable: true },\n      age: { type: \'number\' },\n    }),\n\nThe only searchable field is `surname`: an index will definitely be created to statisfy it\n\nSimpleDbLayer provides two class-level functions that affect all the layers in the registry:\n\n### `SimpleDbLayer.generateSchemaIndexesAllLayers()`\n\nThis function does what it says: it generates all schema indexes for every layer defined in the registry.\n\n### `SimpleDbLayer.dropAllIndexesAllLayers()`\n\nThis function drops all indexes for every layer defined in the registry.\n\n#### A note on inherited classes.\n\nRemember that class functions are inherited by subclasses when subclassing is done using [simpleDeclare](https://github.com/mercmobily/simpleDeclare). So, if you define your layer like this:\n\n      // Make up the database class\n      var DbLayer = declare( [ SimpleDbLayer, SimpleDbLayerMongo ], { db: db } );\n\nYou can run `DbLayer.generateSchemaIndexesAllLayers()` as well as `SimpleDbLayer.generateSchemaIndexesAllLayers()`.\n\n# Layer registry\n\nWhen you create a layer, you define the layer\'s name. In this case, for example, the layer\'s name is \'emails\':\n\n    var emails = new DbLayer( \'emails\', {\n\n      schema: new SimpleSchema({\n        id: { type: \'id\' },\n        personId: { type: \'id\' },\n        email: { type: \'string\', required: true },\n      }),\n\n      idProperty: \'id\',\n\n    } );\n\nSimpleDbLayer keeps a registry of layers, accessible through "class calls".\n\nThis mechanism is very handy when you want to define your layers in a sub-module and then want to access those variables anywhere in your program.\n\n## DbLayer.getLayer()\n\nThe function `DbLayer.getLayer()` will return a single layer from the layer registry:\n\n    emails = DbLayer.getLayer(\'emails\')\n    // layer is now ready to be used to insert, delete, etc. \n\n## DbLayer.getAllLayers()\n\nThe function `DbLayer.getAllLayers()` will return _all_ layers in the registry:\n\n    allLayers = DbLayer.getAllLayers()\n    // allLayers is now { emails: ..., people: ... }\n\nAs you can see, allLayers is a hash object where each key is the layer\'s name.\n\n# Why another DB abstraction module?\n\nThis module was specificaly created to allow the [JsonRestStores](https://github.com/mercmobily/JsonRestStores) module to interact with several database engines.\n\nUnlike other layers/ORMs, it only does what\'s normally required when dealing with web application data. If you are after a full-blown database abstraction module or ORM, you should look somewhere else.\n\n# Changes\n\nHere I will list the major changes I make to the library\n\n## Changes from "0.3.12", "0.3.13"\n\n* BREAKING idProperty is now mandatory, and it\'s forced in the schema as searchable and required\n* BREAKING Schema needs to be defined, fields have searchable (boolean) and required (boolean)\n* positionField and positionBase are now here\n* insert and update have the skipValidation option\n* constructor can be passed the validationError object, which will be created (explain how)\n* There is a global layer registry, accessible as SimpleDbLayer.getLayer(), SimpleDbLayer.getAllLayers()\n* [index] New index functions makeAllIndexes(), dropAllIndexes(), makeIndex()\n* [index] Global index funcs SimpleDbLayer.makeAllIndexesAllLayers() and SimpleDbLayer.dropAllIndexesAllLayers()\n* [index] A field can be defined as indexPrefix ( will be used as prefix), and permute (will be permuted among others defined with permute).\n* [nested] It is now possible to define nested tables, for 1:n relationships and 1:1 (lookup) relationships\n* [nested] { children: true } option in select()\n* [nested] If using nested layers, SimpleDbLayer.initLayers() needs to be called before any db operation\n\n\n',
76 silly publish   readmeFilename: 'README.md',
76 silly publish   bugs: { url: 'https://github.com/mercmobily/simpledblayer/issues' },
76 silly publish   homepage: 'https://github.com/mercmobily/simpledblayer',
76 silly publish   _id: 'simpledblayer@0.3.16',
76 silly publish   dist: { shasum: '461c5f78add210b8e8e949a2be35e9d4b95acae3' },
76 silly publish   _from: '.' }
77 verbose url raw simpledblayer
78 verbose url resolving [ 'https://registry.npmjs.org/', './simpledblayer' ]
79 verbose url resolved https://registry.npmjs.org/simpledblayer
80 info trying registry request attempt 1 at 07:04:29
81 http PUT https://registry.npmjs.org/simpledblayer
82 http 403 https://registry.npmjs.org/simpledblayer
83 error publish Failed PUT 403
84 error Error: forbidden cannot modify pre-existing version: 0.3.16
84 error old={"name":"simpledblayer","description":"Simple, generic, no fuss DB layer for NodeJS","keywords":["javascript","database","mongo"],"main":"SimpleDbLayer.js","version":"0.3.16","private":false,"repository":{"type":"git","url":"https://github.com/mercmobily/simpledblayer"},"author":{"name":"Tony Mobily"},"dependencies":{"simpledeclare":"0.3.x","async":"0.2.x"},"bugs":{"url":"https://github.com/mercmobily/simpledblayer/issues"},"homepage":"https://github.com/mercmobily/simpledblayer","_id":"simpledblayer@0.3.16","dist":{"shasum":"461c5f78add210b8e8e949a2be35e9d4b95acae3","tarball":"http://registry.npmjs.org/simpledblayer/-/simpledblayer-0.3.16.tgz"},"_from":".","_npmVersion":"1.4.3","_npmUser":{"name":"mercmobily","email":"tonymobily@gmail.com"},"maintainers":[{"name":"mercmobily","email":"tonymobily@gmail.com"}]}
84 error new={"name":"simpledblayer","description":"Simple, generic, no fuss DB layer for NodeJS","keywords":["javascript","database","mongo"],"main":"SimpleDbLayer.js","version":"0.3.16","private":false,"repository":{"type":"git","url":"https://github.com/mercmobily/simpledblayer"},"author":{"name":"Tony Mobily"},"dependencies":{"simpledeclare":"0.3.x","async":"0.2.x"},"readme":"simpledblayer\u000a=============\u000a\u000aSimpleDbLayer is a module that will allow you to connect and query a DB server. Key features:\u000a\u000a* It doesn't manage connections. You will have to create a connection to the database and pass it\u000a* Simple querying. You cannot create complex queries with nested ANDs and ORs -- only one level of AND and OR. You can however check for equality, greater/smaller than, starts with/ends with/contains, etc. as well as sorting and limiting/ranges\u000a* It has full cursor support\u000a* It uses a schema to cast/validate fields.\u000a* It allows 1-level joins in queryes and data fetching. This means that you can load a record and have all of its \"lookup\" fields, or all of its 1:n children, pre-loaded.\u000a* It is written with very simple, Object Oriented code using [simpleDeclare](https://github.com/mercmobily/simpleDeclare)\u000a\u000a\u000a## TODO\u000a\u000aTodo when everything is stable and non-structural, non-API-changing changes can be made:\u000a\u000a* searchableHash -> change it to the field type, 'string', 'id', etc.\u000a* make DB a normal parameter, rather than the constructor's third parameter\u000a* take out \"join\" for lookup tables, since it can be inferred easily\u000a\u000a# Creating a layer\u000a\u000a## Create a DB connection\u000a\u000aSimpleDbLayer does NOT handle DB connections for you. It's your responsibility to connect to the database and pass the connection object to it.\u000aFor MongoDB, you can use Mongo's connect call:\u000a\u000a    var mongo = require('mongo');\u000a    mongo.MongoClient.connect( 'mongodb://localhost/hotplate', {}, function( err, db ){\u000a     // db exists here\u000a    }; \u000a\u000aOr for Tingodb just create the DB object:\u000a\u000a    var tingo = require(\"tingodb\")({});\u000a    var db = new tingo.Db('/tmp/someDB', {} );\u000a    // db exists here\u000a\u000a## Make up the DB Layer class\u000a\u000aIn order to use this class, you will need to _mixin_ the basic SimpleDbLayer class and a DB-specific mixin. If you are not used to mixins, don't be scared: it's simpler than it sounds.\u000a\u000aHere is how you make up the class:\u000a\u000a    var mongo = require('mongodb');\u000a\u000a    var declare = require('simpledeclare');\u000a    var SimpleDbLayer = require('simpledblayer'); // This is the main class\u000a    var SimpleSchema = require('simpleschema'); // This will be used to define the schema\u000a    var SimpleDbLayerMongo = require('simpledblayer-mongo'); // This is the layer-specific mixin\u000a\u000a    // Connect to the database\u000a    mongo.MongoClient.connect('mongodb://localhost/someDB', {}, function( err, db ){\u000a\u000a      // Make up the database class\u000a      var DbLayer = declare( [ SimpleDbLayer, SimpleDbLayerMongo ], { db: db } );\u000a\u000a      // ...your program goes here\u000a\u000a    });\u000a\u000aOr, you could use TingoDB:\u000a\u000a    var tingo = require(\"tingodb\")({});\u000a\u000a    var declare = require('simpledeclare');\u000a    var SimpleDbLayer = require('simpledblayer'); // This is the main class\u000a    var SimpleSchema = require('simpleschema'); // This will be used to define the schema\u000a    var SimpleDbLayerTingo = require('simpledblayer-tingo'); // This is the layer-specific mixin\u000a\u000a    var db = new tingo.Db('/tmp/someDB', {} );\u000a\u000a    // Make up the database class\u000a    var DbLayer = declare( [ SimpleDbLayer, SimpleDbLayerTingo ], { db: db } );\u000a\u000a    // ...your program goes here\u000a\u000aThere is no difference in functionality between the two layers.\u000a\u000a## Create your layer object\u000a\u000aOnce you have your DbLayer class, it's up to you to create objects which will then modify specific database tables/collections:\u000a\u000a    var people = new DbLayer( 'people', {\u000a\u000a      schema: new SimpleSchema({\u000a        id: { type: 'id' },\u000a        name: { type: 'string', required: true },\u000a        surname: { type: 'string', searchable: true },\u000a        age: { type: 'number', searchable: true },\u000a      }),\u000a\u000a      idProperty: 'id',\u000a\u000a    } );\u000a\u000aNote how `people` is an object which will be tied to the table/collection `people`.\u000aThe second parameter in the constructor is a set of parameters, which in this case include 1) The schema definition 2) the `idProperty`, which needs to be set and refer to an existing field.\u000a\u000aSimpleschema is an object based on [SimpleSchema](https://github.com/mercmobily/SimpleSchema), which provides a way to define extensible schemas with a very simple API. In this case, the `name` field is required whereas `surname` and `age` are not required but are searchable.\u000a\u000aThe `id` field, since it was set as `isProperty`, is forced as `required` and `searchable`.\u000a\u000a## Create your layer object with a specific db connection\u000a\u000aYou can pass the connection variable `db` as the third parameter of the DbLayer constructor if you like:\u000a\u000a    var logEntries = new DbLayer( 'logger', { ...layer parameters... }, someOtherDb );\u000a\u000aIn this case, logEntries will be tied to the table `logger`, but queries will be directed to `someOtherDb` rather than `db`.\u000a\u000a## Setting a hard limit on queries\u000a\u000aCursor-less queries on large data sets will likely chew up huge amounts of memory. This is why you can set a hard limit on queries:\u000a\u000a      var DbLayer = declare( [ SimpleDbLayer, SimpleDbLayerMongo ], { db: db, hardLimitOnQueries: 10 } );\u000a\u000aThis will imply that each non-cursor query will only ever return 10 items max. You can also set this limit on specific objects by passing hardLimitOnQueries as a parameter:\u000a\u000a    var DbLayer = declare( [ SimpleDbLayer, SimpleDbLayerMongo ], { db: db } );\u000a    var people = new DbLayer( 'people', {  ...layer parameters..., hardLimitOnQueries: 10 } );\u000a\u000aNote that hardLimtOnQueries only ever applies to non-cursor queries.\u000a\u000a## Validation errors\u000a\u000aThe `insert` and `update` operations will trigger validation against the schema. If validation fails, the callback is called with an error. The error object is created by SimpleDbLayer like this:\u000a\u000a    var error = new Error( { errors: errorsArray } );\u000a    error.errors = errorsArray;\u000a\u000aThe variable `errorsArray` is an array of objects, where each object has `field` and `message` defined. For example:\u000a\u000a    [ { field: 'age', message: 'Age is invalid' }, { field: 'name', message: 'Field is required: name' } ] \u000a\u000aYou can set the constructor used to create the error objects by passing a `SchemaError` parameter when you define the layer:\u000a\u000a    var people = new DbLayer( 'people', {\u000a\u000a      schema: new SimpleSchema({\u000a        // ... your schema here\u000a      }),\u000a\u000a      idProperty: 'id',\u000a\u000a      SchemaError: YourPersonalisedErrorConstructor\u000a    } );\u000a\u000aYou can also define a `SchemaError` that will be used by all instances:\u000a\u000a    var people = new DbLayer( 'people', {  ...layer parameters..., SchemaError: SomeOtherSchemaError } );\u000a\u000a# Running queries\u000a\u000a## Querying: insert\u000a\u000aTo insert data into your table:\u000a\u000a    people.insert( { id: 1, name: 'Tony', surname: 'Mobily', age: 37 }, { returnRecord: true }, function( err, record ){\u000a\u000aThe second parameter is optional. If you pass it:\u000a\u000a* If `returnRecord` is true, then the callback will be called with `record` representing the record just created.\u000a* If `skipValidation` is true, then the validation of the data against the schema will be skipped\u000a\u000a## Querying: update\u000a\u000aThis is a simple update:\u000a\u000a    people.update( { conditions: { and: [ name: { type: 'startsWith', value: 'D' }  ] } }, { name: 'Changed' }, { deleteUnsetFields: true, multi: true }, function( err, num ){\u000a\u000aThe second parameter is optional. If you pass it:\u000a\u000a* If `multi` is set to `true`, all records matching the search will be updated. Otherwise, only one record will be updated.\u000a* If `deleteUnsetFields` is set to `true`, then any field that is not defined in the update object will be set as empty in the database. Basically, it's a \"full record update\" regardless of what was passed. Validation will fail if a field is required by the schema and it's not set while this option is `true`.\u000a* If `skipValidation` is true, then the validation of the data against the schema will be skipped\u000a\u000a## Querying: delete\u000a\u000aTo delete, just use the `delete()` method:\u000a\u000a    people.delete( { conditions: { and: [ { field: 'age', type: 'lt', value: 30 }, { field: 'name', type: 'eq', value: 'Chiara' } ] } }, { multi: true } ,  function( err, howMany ){\u000a\u000aThe second parameter is optional. If you pass it:\u000a\u000a* If `multi` is set to `true`, all records matching the search will be deleted. Otherwise, only one record will be deleted.\u000a\u000a## Querying: select\u000a\u000aFor normal queries:\u000a\u000a    people.select( {}, { useCursor: false , delete: false }, function( err, data, total, grandTotal ){\u000a\u000aIn normal queries, you can also pass the `skipHardLimitOnQueries` flag. However, remember that if you have a large data set, non-cursor queries will attempt to place the whole thing in memory and will probably kill your server:\u000a\u000a    people.select( {}, { useCursor: false , delete: false, skipHardLimitOnQueries: true }, function( err, data, total, grandTotal ){\u000a\u000aFor cursor queries (for which `skipHardLimitOnQueries` is implied since it would be pointless):\u000a\u000a    people.select( {}, { useCursor: true , delete: false }, function( err, cursor, total, grandTotal ){\u000a\u000aHere, `total` is the number of records returned, and `grandTotal` is the _total_ number of records that satisfy the query without taking into consideration the required ranges.\u000a\u000aNormal queries will just return the data as an array of values. Cursor queries will return an object with the methods next(), rewind() and close(). For example:\u000a\u000a    people.select( {}, { useCursor: true , delete: false }, function( err, cursor ){\u000a    if( err ){\u000a      console.log( \"ERROR!\", err );\u000a    } else {\u000a      cursor.next( function( err, record ){\u000a        if( err ){\u000a          console.log( \"ERROR!\", err );\u000a        } else {\u000a          console.log( \"The first record:\" );\u000a          console.log( record );\u000a        } \u000a      }\u000a    }\u000a\u000aThis is what the search filter can look like:\u000a\u000a    var searchFilter = { \u000a  \u000a      ranges: {\u000a        from: 1,\u000a        to: 7\u000a        limit: 7\u000a      },\u000a  \u000a      conditions: {\u000a  \u000a        and: [\u000a          { \u000a            field: 'name',\u000a            type: 'startsWith',\u000a            value: 'To'\u000a          },\u000a        ],\u000a  \u000a        or: [\u000a  \u000a          {\u000a            field: 'age',\u000a            type: 'lt',\u000a            value: 12 \u000a          },\u000a          {\u000a            field: 'age',\u000a            type: 'gt',\u000a            value: 65\u000a          },\u000a\u000a        ],\u000a      },\u000a  \u000a      sort: {\u000a        name: -1,\u000a        age: 1\u000a      }\u000a  \u000a    };\u000a\u000aConditions are grouped into `and` and `or` ones. The db query will be the list of `and` conditions _linked with `and`_ to the list of `or` conditions. See it as `A and B and C and (D or E of F )` where `A`, `B` and `C` are the `and` conditions, and `D`, `E`, `F` are the `or` conditions.\u000a\u000aThe possible comparison types are: `is` `eq` `lt` `lte` `gt` `gte` `startWith` `startsWith` `contain` `contains` `endsWith` `endWith`.\u000a\u000aIf the `delete` field is on (it's off by default), the driver will _delete_ any fetched record. For straight selects, it will delete all records _before_ calling your callback. For cursor-driven selects, it will delete records as they are fetched with `cursor.next()` \u000a\u000aRanges can have `from`, `to` and `limit` set. If `fields` are missing, the others are automatically worked out.\u000aFor sorting, -1 means from smaller to bigger and 1 means from bigger to smaller.\u000a\u000a# Automatic loading of children (joins)\u000a\u000aSimpleDbLayer does _not_ support complex joins. In fact, at the beginning it didn't support joins at all. However, after real world usage of the library, it became apparent that some level of joins was important to easy application development.\u000a\u000a## Define nested layers\u000a\u000aYou can now define a layer as \"child\" of another one:\u000a\u000a    var people = new DbLayer( 'people', {\u000a\u000a      schema: new SimpleSchema({\u000a        id: { type: 'id' },\u000a        name: { type: 'string', required: true },\u000a        surname: { type: 'string', searchable: true },\u000a        age: { type: 'number', searchable: true },\u000a      }),\u000a\u000a      idProperty: 'id',\u000a\u000a      nested: [\u000a        {\u000a          layer: 'emails',\u000a          join: { personId: 'id' },\u000a          type: 'multiple',\u000a        },\u000a      ]\u000a\u000a    } );\u000a\u000a    var emails = new DbLayer( 'emails', {\u000a\u000a      schema: new SimpleSchema({\u000a        id: { type: 'id' },\u000a        personId: { type: 'id' },\u000a        email: { type: 'string', required: true },\u000a      }),\u000a\u000a      idProperty: 'id',\u000a\u000a      nested: [\u000a        {\u000a          layer: 'people',\u000a          type: 'lookup',\u000a          join: { id: 'personId' },\u000a          parentField: 'personId',\u000a        }\u000a      ],\u000a    } );\u000a\u000a    SimpleDbLayer.initLayers(); // <--- IMPORTANT!!!\u000a\u000a\u000a***It's absolutely crucial that you run `SimpleDbLayer.initLayers()` before running queries if you have nested layers.***\u000a\u000aAs you can see, each layer is created with an extra `nested` parameter, which defines:\u000a\u000a* `layer`. The layer you want to automatically load records from\u000a* `type`. How you want to load your records. If you use `multiple`, SimpleDbLayer will auto-load all children records; with `lookup`, it will only load one record\u000a* `join`. How the record will be looked up in the parent table. It's a hash object, where the key is the field _foreign_ to the layer that is being defined, and the value is the field _local_ to the layer that is being defined.\u000a* `parentField`. Only required when `type` is `lookup`, this is the name of the field in the `local` layer that is being defined that will be used.\u000a\u000aThis functionality affects `select()` calls: basically, every time you fetch records, SimpleDbLayer will return a record with a `_children` hash.\u000a\u000a## Getting the results\u000a\u000aAssume that you insert:\u000a\u000a    people.insert( {\u000a\u000a      id: 100,\u000a      name: 'Tony',\u000a      surname: 'Mobily',\u000a      age: 37\u000a\u000a    }, { returnRecord: true }, function( err, record ){\u000a    \u000a      if( err ) return cb( err );\u000a\u000a      email.insert( {\u000a\u000a        id: 10,\u000a        personId: 100,\u000a        email: 'tony@example.com'\u000a\u000a      }, { returnRecord: true }, function( err, record ){\u000a        if( err ) return cb( err );\u000a\u000a      email.insert( {\u000a\u000a        id: 11,\u000a        personId: 100,\u000a        email: 'tonyAnotherOne@example.com'\u000a\u000a      }, { returnRecord: true }, function( err, record ){\u000a        if( err ) return cb( err );\u000a\u000a        //...\u000a\u000aWhen fetching the person with id 100:\u000a\u000a    people.select( { conditions: { and: [ { field: 'id', type: 'eq', value: 100 } ] } }, { children: true }, function( err, data ){\u000a\u000a\u000aSince `children: true` is passed in the option, this will be returned:\u000a\u000a    {\u000a      id: 100,\u000a      name: 'Tony',\u000a      surname: 'Mobily',\u000a      age: 37,\u000a      _children: {\u000a        emails: [\u000a        \u000a          {\u000a            id: 10,\u000a            personId: 100,\u000a            email: 'tony@example.com'\u000a            _children: {},\u000a          },\u000a\u000a          {\u000a            id: 11,\u000a            personId: 100,\u000a            email: 'tonyAnotherOne@example.com'\u000a            _children: {},\u000a          }\u000a\u000a        ],\u000a\u000a      }\u000a    }\u000a\u000a\u000aWhen fetching the email with id 10:\u000a\u000a    emails.select( { conditions: { and: [ { field: 'id', type: 'eq', value: 10 } ] } }, { children: true }, function( err, data ){\u000a\u000a, it will return:\u000a\u000a    {    \u000a      id: 10,\u000a      personId: 100,\u000a      email: 'tony@example.com',\u000a      _children: {\u000a\u000a        personId: {\u000a          id: 100,\u000a          name: 'Tony',\u000a          surname: 'Mobily',\u000a          age: 37\u000a        },\u000a      }\u000a    }\u000a\u000aFinally, you can change the name of the `_children` field when instantiating the class, by setting a different `childrenField` attribute:\u000a\u000a    var people = new DbLayer( 'people', {\u000a\u000a      schema: new SimpleSchema({\u000a        id: { type: 'id' },\u000a        name: { type: 'string', required: true },\u000a        surname: { type: 'string', searchable: true },\u000a        age: { type: 'number', searchable: true },\u000a      }),\u000a\u000a      idProperty: 'id',\u000a\u000a      nested: [\u000a        {\u000a          layer: 'emails',\u000a          join: { personId: 'id' },\u000a          type: 'multiple',\u000a        },\u000a      ]\u000a\u000a      childrenField: '_children',\u000a    } );\u000a\u000a\u000a# Positioning\u000a\u000aWhen records are fetched (using `select`) without chosing any `sort`ing options, they are returned in random order. However, in web applications you often want to decide the `placement` of an element, in order to allow drag&drop sorting etc.\u000a\u000aPositioning is tricky to manage from the application layer, as changing a field's position requires the update of several records in the database. This is why SimpleDbLayer handles positioning for you.\u000a\u000a## Basic positioning\u000a\u000aIf you have a \"flat\" table, you can simply define the `positionField` attribute when you define the constructor:\u000a\u000a    var people = new DbLayer( 'people', {\u000a\u000a      schema: new SimpleSchema({\u000a        id: { type: 'id' },\u000a        name: { type: 'string', required: true },\u000a        surname: { type: 'string', searchable: true },\u000a        age: { type: 'number', searchable: true },\u000a      }),\u000a\u000a      idProperty: 'id',\u000a\u000a      positionField: 'position',\u000a    } );\u000a\u000aNote that `positionField` is _not_ defined in the schema. In fact, it will be completely _invisible_ to the application using SimpleDbLayer: it won't be returned in `select` queries, and won't be updatable.\u000a\u000aImagine that you add some data:\u000a\u000a    var tony = { id: 1, name: 'Tony', surname: 'Mobily', age: 37 };\u000a    var chiara = { id: 2, name: 'Chiara', surname: 'Mobily', age: 23 };\u000a\u000a    people.insert( tony, { returnRecord: true }, function( err, tony ){\u000a      if( err ) return cb( err );\u000a\u000a      people.insert( chiara, { returnRecord: true }, function( err, chiara ){\u000a        if( err ) return cb( err );\u000a        // ...\u000a\u000aAt this point, you decide to position the record with `id` 2 (chiara) _before_ the one with id `1`. Just run:\u000a\u000a    people.reposition( chiara, 1, function( err ){\u000a\u000aThe records' `position` field on the database will be updated so that they are in the right order.\u000a\u000aFrom now on, when running `select` calls _without_ any sorting options, SimpleDbLayer will return them sorted by the `position` field.\u000a\u000a## Nested record positioning\u000a\u000aIn most cases, your records will be \"nested\" to other ones. Imagine these two layers:\u000a\u000a    var people = new DbLayer( 'people', {\u000a\u000a      schema: new SimpleSchema({\u000a        id: { type: 'id' },\u000a        name: { type: 'string', required: true },\u000a        surname: { type: 'string', searchable: true },\u000a        age: { type: 'number', searchable: true },\u000a      }),\u000a\u000a      idProperty: 'id',\u000a\u000a    } );\u000a\u000a    var emails = new DbLayer( 'emails', {\u000a\u000a      schema: new SimpleSchema({\u000a        id: { type: 'id' },\u000a        personId: { type: 'id' },\u000a        email: { type: 'string', required: true },\u000a      }),\u000a\u000a      idProperty: 'id',\u000a\u000a    } );\u000a\u000aEach person will have a number of emails -- all the ones with the corresponding personId. When dealing with positioning, you need to take into account what fields define the 'ordering grouping': placing an email address before another one should only ever affect the records belonging to the same person.\u000a\u000aThis is where the `positionBase` array comes in.\u000a\u000aThis is how you would make the `emails` layer able to handle positioning:\u000a\u000a    var emails = new DbLayer( 'emails', {\u000a\u000a      schema: new SimpleSchema({\u000a        id: { type: 'id' },\u000a        personId: { type: 'id' },\u000a        email: { type: 'string', required: true },\u000a      }),\u000a\u000a      idProperty: 'id',\u000a\u000a      positionField: 'position',\u000a      positionBase: [ 'personId' ],\u000a\u000a    } );\u000a\u000aThe attribute `positionBase` basically decides the domain in which the reordering will happen: only records where `personId` matches the moving record's `personId` will be affected by repositioning.\u000a\u000a\u000a# Indexing\u000a\u000aYou can create and delete indexes using SimpleDbLayer.\u000aThe methods are:\u000a\u000a## `makeIndex( keys, name, options, cb )`\u000a\u000aThe method `makeIndex` will create an index. When calling the function:\u000a\u000a* `keys` is an hash where each key is the field name, and each value can be `1` (ascending order) or `-1` (descending order). So, if you have `{ name: 1, surname: 1 }`, the database will be instructed to create an index with the fields `name` and `surname`, both in ascending order.\u000a* `name` is the name of your index.\u000a* `options` is a hash where: `{ background: true }` will start the process in background; `unique` will instruct the database that the index will need to be unique; `name` will force the index name to a specific label, rather than the database's default.\u000a\u000a## `dropIndex( name, cb)`\u000a\u000aThis metod `dropIndex()` will drop an index.\u000a\u000a## `dropAllIndexes()`\u000a\u000aThe method `dropAllIndexes` will drop all indexes for the table/collection.\u000a\u000a## `generateSchemaIndexes()`\u000a\u000aThis function is used to generate indexes depending on what fields are marked as `searchable` in the schema. The implementation of this depends on the capabilities and architecture of the database server you are using. The goal is to make sure that all searches are based on indexes.\u000a\u000aImagine that you have a schema so defined:\u000a\u000a    schema: new SimpleSchema({\u000a      id: { type: 'id' },\u000a      name: { type: 'string', required: true },\u000a      surname: { type: 'string', searchable: true },\u000a      age: { type: 'number' },\u000a    }),\u000a\u000aThe only searchable field is `surname`: an index will definitely be created to statisfy it\u000a\u000aSimpleDbLayer provides two class-level functions that affect all the layers in the registry:\u000a\u000a### `SimpleDbLayer.generateSchemaIndexesAllLayers()`\u000a\u000aThis function does what it says: it generates all schema indexes for every layer defined in the registry.\u000a\u000a### `SimpleDbLayer.dropAllIndexesAllLayers()`\u000a\u000aThis function drops all indexes for every layer defined in the registry.\u000a\u000a#### A note on inherited classes.\u000a\u000aRemember that class functions are inherited by subclasses when subclassing is done using [simpleDeclare](https://github.com/mercmobily/simpleDeclare). So, if you define your layer like this:\u000a\u000a      // Make up the database class\u000a      var DbLayer = declare( [ SimpleDbLayer, SimpleDbLayerMongo ], { db: db } );\u000a\u000aYou can run `DbLayer.generateSchemaIndexesAllLayers()` as well as `SimpleDbLayer.generateSchemaIndexesAllLayers()`.\u000a\u000a# Layer registry\u000a\u000aWhen you create a layer, you define the layer's name. In this case, for example, the layer's name is 'emails':\u000a\u000a    var emails = new DbLayer( 'emails', {\u000a\u000a      schema: new SimpleSchema({\u000a        id: { type: 'id' },\u000a        personId: { type: 'id' },\u000a        email: { type: 'string', required: true },\u000a      }),\u000a\u000a      idProperty: 'id',\u000a\u000a    } );\u000a\u000aSimpleDbLayer keeps a registry of layers, accessible through \"class calls\".\u000a\u000aThis mechanism is very handy when you want to define your layers in a sub-module and then want to access those variables anywhere in your program.\u000a\u000a## DbLayer.getLayer()\u000a\u000aThe function `DbLayer.getLayer()` will return a single layer from the layer registry:\u000a\u000a    emails = DbLayer.getLayer('emails')\u000a    // layer is now ready to be used to insert, delete, etc. \u000a\u000a## DbLayer.getAllLayers()\u000a\u000aThe function `DbLayer.getAllLayers()` will return _all_ layers in the registry:\u000a\u000a    allLayers = DbLayer.getAllLayers()\u000a    // allLayers is now { emails: ..., people: ... }\u000a\u000aAs you can see, allLayers is a hash object where each key is the layer's name.\u000a\u000a# Why another DB abstraction module?\u000a\u000aThis module was specificaly created to allow the [JsonRestStores](https://github.com/mercmobily/JsonRestStores) module to interact with several database engines.\u000a\u000aUnlike other layers/ORMs, it only does what's normally required when dealing with web application data. If you are after a full-blown database abstraction module or ORM, you should look somewhere else.\u000a\u000a# Changes\u000a\u000aHere I will list the major changes I make to the library\u000a\u000a## Changes from \"0.3.12\", \"0.3.13\"\u000a\u000a* BREAKING idProperty is now mandatory, and it's forced in the schema as searchable and required\u000a* BREAKING Schema needs to be defined, fields have searchable (boolean) and required (boolean)\u000a* positionField and positionBase are now here\u000a* insert and update have the skipValidation option\u000a* constructor can be passed the validationError object, which will be created (explain how)\u000a* There is a global layer registry, accessible as SimpleDbLayer.getLayer(), SimpleDbLayer.getAllLayers()\u000a* [index] New index functions makeAllIndexes(), dropAllIndexes(), makeIndex()\u000a* [index] Global index funcs SimpleDbLayer.makeAllIndexesAllLayers() and SimpleDbLayer.dropAllIndexesAllLayers()\u000a* [index] A field can be defined as indexPrefix ( will be used as prefix), and permute (will be permuted among others defined with permute).\u000a* [nested] It is now possible to define nested tables, for 1:n relationships and 1:1 (lookup) relationships\u000a* [nested] { children: true } option in select()\u000a* [nested] If using nested layers, SimpleDbLayer.initLayers() needs to be called before any db operation\u000a\u000a\u000a","readmeFilename":"README.md","bugs":{"url":"https://github.com/mercmobily/simpledblayer/issues"},"homepage":"https://github.com/mercmobily/simpledblayer","_id":"simpledblayer@0.3.16","dist":{"shasum":"461c5f78add210b8e8e949a2be35e9d4b95acae3","tarball":"http://registry.npmjs.org/simpledblayer/-/simpledblayer-0.3.16.tgz"},"_from":".","_npmVersion":"1.4.3","_npmUser":{"name":"mercmobily","email":"tonymobily@gmail.com"},"maintainers":[{"name":"mercmobily","email":"tonymobily@gmail.com"}]}: simpledblayer
84 error     at RegClient.<anonymous> (/usr/local/lib/node_modules/npm/node_modules/npm-registry-client/lib/request.js:237:14)
84 error     at Request.self.callback (/usr/local/lib/node_modules/npm/node_modules/request/request.js:123:22)
84 error     at Request.EventEmitter.emit (events.js:98:17)
84 error     at Request.<anonymous> (/usr/local/lib/node_modules/npm/node_modules/request/request.js:893:14)
84 error     at Request.EventEmitter.emit (events.js:117:20)
84 error     at IncomingMessage.<anonymous> (/usr/local/lib/node_modules/npm/node_modules/request/request.js:844:12)
84 error     at IncomingMessage.EventEmitter.emit (events.js:117:20)
84 error     at _stream_readable.js:920:16
84 error     at process._tickCallback (node.js:415:13)
85 error If you need help, you may report this *entire* log,
85 error including the npm and node versions, at:
85 error     <http://github.com/npm/npm/issues>
86 error System Linux 3.13.0-18-generic
87 error command "/usr/local/bin/node" "/usr/local/bin/npm" "publish"
88 error cwd /disk/home/merc/Synced/Development/node/dev/node_modules/simpledblayer
89 error node -v v0.10.26
90 error npm -v 1.4.3
91 verbose exit [ 1, true ]
